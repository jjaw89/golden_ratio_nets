
from cmath import sqrt
import numpy as np
import time
import sys
import cupy as cp
import math
import scipy.special


import matplotlib.pyplot as plt
from sympy import GoldenRatio, plot
plt.style.use('seaborn-whitegrid')

GOLDEN_RATIO = ((1+sqrt(5))/2).real


def no_consecutive_ones(length):
    end_in_zero = np.zeros((1, 1), dtype=int)
    end_in_one = np.ones((1, 1), dtype=int)

    for i in range(length-1):
        end_in_zero_zero = np.append(end_in_zero,
                                     np.zeros(
                                         (end_in_zero.shape[0], 1), dtype=int),
                                     axis=1)
        end_in_zero_one = np.append(end_in_zero,
                                    np.ones(
                                        (end_in_zero.shape[0], 1), dtype=int),
                                    axis=1)
        end_in_one_zero = np.append(end_in_one,
                                    np.zeros(
                                        (end_in_one.shape[0], 1), dtype=int),
                                    axis=1)
        end_in_zero = np.append(end_in_zero_zero, end_in_one_zero, axis=0)
        end_in_one = end_in_zero_one

    return np.append(end_in_one, end_in_zero, axis=0)


def no_consecutive_ones_b(length):
    end_in_zero = np.zeros((1, 1), dtype='b')
    end_in_one = np.ones((1, 1), dtype='b')

    for i in range(length-1):
        end_in_zero_zero = np.append(end_in_zero,
                                     np.zeros(
                                         (end_in_zero.shape[0], 1), dtype='b'),
                                     axis=1)
        end_in_zero_one = np.append(end_in_zero,
                                    np.ones(
                                        (end_in_zero.shape[0], 1), dtype='b'),
                                    axis=1)
        end_in_one_zero = np.append(end_in_one,
                                    np.zeros(
                                        (end_in_one.shape[0], 1), dtype='b'),
                                    axis=1)
        end_in_zero = np.append(end_in_zero_zero, end_in_one_zero, axis=0)
        end_in_one = end_in_zero_one

    return np.append(end_in_one, end_in_zero, axis=0)


def golden_multiplied_2d(num_digits):
    multiplied_matrix = np.array(
        [[GOLDEN_RATIO ** (-1), GOLDEN_RATIO ** (-num_digits)]])
    for i in range(2, num_digits+1):
        multiplied_matrix = np.append(multiplied_matrix,
                                      [[GOLDEN_RATIO ** (-i), GOLDEN_RATIO ** (i-num_digits-1)]], axis=0)
    print(multiplied_matrix)
    return multiplied_matrix


def golden_multiplied_1d(num_digits):
    multiplied_matrix = np.array(
        [[GOLDEN_RATIO ** (-1)]])
    for i in range(2, num_digits+1):
        multiplied_matrix = np.append(multiplied_matrix,
                                      [[GOLDEN_RATIO ** (-i)]], axis=0)
    return multiplied_matrix


def partition(num_digits):
    if num_digits == 0:
        return np.array([0, 1]).real
    numbers = np.matmul(no_consecutive_ones_b(
        num_digits), golden_multiplied_1d(num_digits))
    numbers = np.append(numbers[numbers[:, 0].argsort()], [[1]], axis=0)
    return numbers.real[:, 0]


def points(num_digits):
    points = np.matmul(no_consecutive_ones_b(
        num_digits), golden_multiplied_2d(num_digits))
    points = points[points[:, 0].argsort()]
    return points.real


# start_time = time.perf_counter()
# vectors = no_consecutive_ones(num_digits)
# print(vectors)
# print(vectors.shape)
# end_time = time.perf_counter()
# print(sys.getsizeof(vectors))
# print(f"Execution Time : {end_time-start_time:0.6f}")

# start_time = time.perf_counter()
# vectors = no_consecutive_ones_b(num_digits)
# print(vectors)
# print(vectors.shape)
# print(sys.getsizeof(vectors))
# end_time = time.perf_counter()

# num_digits = 32

# start_time = time.perf_counter()
# print(points(num_digits))
# end_time = time.perf_counter()
# print(f"Execution Time : {end_time-start_time:0.6f}")

# print(f"Number of Digits : {num_digits}")

# start_time = time.perf_counter()
# zeros_and_ones = no_consecutive_ones_b(
#     num_digits)
# end_time = time.perf_counter()
# print(f"Zeros and Ones Time : {end_time-start_time:0.6f}")

# start_time = time.perf_counter()
# points = np.matmul(zeros_and_ones, golden_multiplied_2d(num_digits))
# end_time = time.perf_counter()
# print(f"Matrix Multiplication Time : {end_time-start_time:0.6f}")


# start_time = time.perf_counter()
# points = points[points[:, 0].argsort()]
# end_time = time.perf_counter()

# print(points.shape)

# print(f"Sort Time : {end_time-start_time:0.6f}")


# print(num_digits)
# start_time = time.perf_counter()
# partition(num_digits)
# end_time = time.perf_counter()

# print(f"Total Time : {end_time-start_time:0.6f}")


# x = np.array([1, 2, 3])
# y = np.array([1, 2, 3])

# plt.plot(x, y, 'o', color='black')

def plot_hammersley(num_digits, x_partition, ypartition):
    hammersley = points(num_digits)
    x = hammersley[:, 0]
    y = hammersley[:, 1]
    plt.figure(figsize=(8, 8))
    ax = plt.gca()
    ax.set_aspect(1)
    plt.plot(x, y, 'o')
    plt.title(f'Base golden ratio Hammersley set with {num_digits} digits')
    plt.grid()
    plt.xticks(ticks=partition(x_partition), labels=[])
    plt.yticks(ticks=partition(ypartition), labels=[])
    plt.xlim((0, 1))
    plt.ylim((0, 1))
    plt.grid()
    plt.show()


# num_digits = 4
# x_partition_num_digits = 0
# y_partition_num_digits = 1


# hammersley_points = points(num_digits)
# print(hammersley_points)

# x_partition = partition(x_partition_num_digits)
# print(x_partition)
# x_axis_bins = [[] for i in range(x_partition.size-1)]
# # print(x_axis_bins)

# bin_number = 0
# for point in list(hammersley_points):
#     if point[0] > x_partition[bin_number + 1]:
#         bin_number = bin_number + 1
#     else:
#         x_axis_bins[bin_number].append(list(point))

# for bin in x_axis_bins:
#     bin.sort(key=lambda x: x[1])


# y_partition = partition(y_partition_num_digits)
# y_axis_bins = [[[] for j in range(y_partition.size-1)]
#                for i in range(x_partition.size-1)]
# print(y_partition)
# # print(y_axis_bins)

# for x_bin_number in range(len(x_axis_bins)):
#     y_bin_number = 0
#     for point in x_axis_bins[x_bin_number]:
#         if point[1] > y_partition[y_bin_number + 1]:
#             y_bin_number = y_bin_number + 1
#         else:
#             y_axis_bins[x_bin_number][y_bin_number].append(list(point))

# print(hammersley_points.shape)
# print(GOLDEN_RATIO)
# print(hammersley_points)
# print()
# print(x_axis_bins)
# print()
# print(y_axis_bins)

# num_digits = 3
# vectors = no_consecutive_ones_b(num_digits)
# vectors_1 = vectors[np.lexsort(np.rot90(vectors))]
# print(vectors_1)
# vectors = no_consecutive_ones_b(num_digits+3)
# vectors_2 = vectors[np.lexsort(np.rot90(vectors))]
# print(vectors_2)
# # print(np.prod(vectors[0] <= vectors[2]))

# num_digits = 6
# plot_hammersley(num_digits, 5, 0)
# num_digits = 5
# print(np.array([[scipy.special.binom(i, j)
#                  for i in range(0, num_digits)] for j in range(0, num_digits)]))

# print()
# matrix = np.array([[scipy.special.binom(i, j) % 2
#                     for i in range(0, num_digits)] for j in range(0, num_digits)])

# matrix = np.array([
#     [1., 0., 1., 0., 1.],
#     [0., 1., 0., 1., 0.],
#     [0., 0., 1., 0., 0.],
#     [0., 0., 0., 1., 0.],
#     [0., 0., 0., 0., 1.]])


# print(matrix)
# print()
# print(vectors)
# print()
# multiplied = np.matmul(matrix, vectors)

# print(multiplied % 2)


def kronecker(num_digits):
    vectors = no_consecutive_ones_b(num_digits)
    print(vectors)
    vectors = vectors[np.lexsort(np.rot90(vectors))]
    print(vectors)
    print()
    x_coords = np.matmul(vectors, np.flip(
        golden_multiplied_1d(num_digits))).real
    print(x_coords)
    y_coords = np.array([[0.]])
    generator = GOLDEN_RATIO - 1
    for n in range(1, x_coords.size):
        y_coords = np.append(
            y_coords, [[generator * n - math.floor(generator * n)]], axis=0)
    print(y_coords)

    plt.figure(figsize=(8, 8))
    ax = plt.gca()
    ax.set_aspect(1)
    plt.plot(x_coords[:, 0], y_coords[:, 0], 'o')
    plt.title(f'Base golden ratio Hammersley set with {num_digits} digits')
    plt.grid()
    plt.xticks(ticks=partition(num_digits), labels=[])
    plt.yticks(ticks=y_coords[:, 0], labels=[])
    plt.xlim((0, 1))
    plt.ylim((0, 1))
    plt.grid()
    plt.show()
    return


def van_der_corput(num_digits):
    vectors = no_consecutive_ones_b(num_digits)
    print(vectors)
    vectors = vectors[np.lexsort(np.rot90(vectors))]
    print(vectors)
    print()
    x_coords = np.matmul(vectors, np.flip(
        golden_multiplied_1d(num_digits))).real
    print(x_coords)
    return


vectors = no_consecutive_ones_b(5)
vectors = vectors[np.lexsort(np.rot90(vectors))]
print(np.fliplr(vectors))
print(vectors)
# plot_hammersley(1, 5, 5)
# van_der_corput(6)
